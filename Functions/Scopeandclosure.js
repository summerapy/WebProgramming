/*
TODO: Scope
 what: 식별자를 참조할 수 있는 코드의 부분
 var: 함수 레벨 스코프
 let, const: 블록 레벨 스코프 (if, for, 함수, ...)
 동적 스코프: 함수 호출시에 결정됨
 정적 스코프 (lexical scope): 함수 정의시 결정됨

TODO: Closure 1
 생명주기(life cycle)가 끝난 outer의 내부 변수를 참조할 수 있는 inner() 함수 →
closure
 클로저가 되는 경우: 중첩함수가 상위 스코프의 식별자를 참조하고 있고 외부 함수보다 더 오래 살아 있는 경우
 자유 변수: 클로저가 참조하는 변수

 why closure
 하나의 state가 의도치 않게 변경되지 않도록 state를 안전하게 은닉
 특정 함수에게만 state 변경을 허용

TODO: Closure 2
 What
 함수와 렉시컬 환경의 조합
 함수가 생성될 당시의 외부 변수를 기억
 생성 이후에도 계속 접근 가능
 함수를 함수 안에 정의하면 내부 함수는 외부 함수의 scope에 접근 가능 →
debugger로 확인 !

 활용
 function 덧셈()에서 '초기값'은 closure에서 접근할 수 있음
 함수가 만들어진 시점에, 함수의 부모 함수가 가지는 scope을 함수가 접근가능 =>
closure

 정의
 MDN - 함수와 함수가 선언된 어휘적 환경의 조합
 코어 자바스크립트 - 어떤 함수 A에서 선언한 변수 a를 참조하는 내부 함수 B를 외
부로 전달할 경우, A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는
현상

TODO: Closure 3
 클로저 – 내부 함수가 외부 함수의 문맥(context)에 접근할 수 있는 것
 외부 함수가 더 이상 사용되지 않는 경우에도, 내부 함수는 외부 함수에 접근할
수 있음

 private variable
 아무나 변경할 수 없음 → 캡슐화 !
 title → get(), set()으로만 접금하도록
 ghost와 matrix는 서로 다른 문맥을 가짐


*/